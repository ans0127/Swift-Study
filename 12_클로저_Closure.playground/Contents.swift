import UIKit

/*======================================================================
 클로저
 - 이름이 없는 함수(익명함수)
 - 함수와 기능은 완전히 동일하지만 형태만 다르다.
 - swift 에서 중괄호({ })는 함수이다!!
 ======================================================================*/

//함수와 클로저
var f : String = "function"

func myFunc(f: String)->(String){    //함수
    return "hello \(f)"
}

let myf = {(f: String)->(String) in  //클로저
    return "hello \(f)"
}

let nth = {() -> (String) in
    return "nothing in out"
}

myFunc(f: "hi")
myf("벼리안냥")
nth()


/*======================================================================
 ✨클로저는 함수를 1급객체로 취급한다.✨
    💠1급 객체의 3가지 의미💠
 - 함수를 변수에 할당할 수 있다.
 - 파라미터로 전달이 가능하다.
 - 함수에서 함수를 return할 수 있다.
 ======================================================================*/

// 클로저를 변수에 할당할 수 있다.
var cls = {(s:String)->(String) in
    return s + "!!!!!"
}

cls("벼리야")



//클로저의 형태
// - 리턴형을 생략할 수 있다.
var str = "벼리야 야옹"

let ac = {(str : String) in
    return str + "!!!!!"
}

let ac2 : (String) -> (String) = {(str) in  //타입추론이 가능할 경우 input타입도 생략 가능하다.
    return str + "????"
}

let ac3 = {         //input output이 없어도 return값이 string 이라는 것을 컴파일러가 알기 때문에 타입추론이 가능하다.
    print("벼리가 야옹")
}


ac("벼리야옹")
ac2("벼리야야옹")
ac3()

//- 파라미터의 타입도 생략이 가능하다.
let ac4 = { str in
    return str + "?!!???!?!?"
}
ac4("야옹벼리야옹")




/*======================================================================
 ✨✨✨✨✨✨✨✨클로저를 사용하는 이유 ✨✨✨✨✨✨✨✨
 - 함수의 이름이 없는 이유: 함수를 실행 할 때 파라미터로 사용되는 형태이기 때문에 이름이 필요없다.
 ======================================================================*/

//1. 클로저를 파라미터로 받는 함수 정의
func closureParamFunction(closure : () -> ()){      //2.파라미터로  printClosureFuncInVar 던짐
    print("벼리가 야옹하고 울기 시작!!")                   //3.(*print)closureParamFunction 실행시 첫줄 실행 & print
    closure()                                       //4.closure함수 실행 - 파라미터로 받은 printClosureFuncInVar 실행
    
}

//2.클로저 함수 정의---------------------------------
func printSwiftFunction(){
    print("벼리가 swift function에서 야옹")
}

var printClosureFuncInVar = { () -> () in
    print("벼리가 closure function에서 야옹")          //5.(*print) printClosureFuncInVar 실행 - print
}
//-----------------------------------------------



//3.함수를 파라미터에 넣으면서 실행
print("함수를 파라미터로 넣으면서 전달---------------------------")
closureParamFunction(closure: printSwiftFunction)       //함수전달
print("클로저함수 파라미터로 넣으면서 전달-----------------------")
closureParamFunction(closure: printClosureFuncInVar)    //클로저함수 전달      1.closureParamFunction 함수 실행




//4. 클로저를 정의하면서 함수를 파라미터에 넣으면서 실행
print("💠 -- 보통 클로저 함수를 정의하면서 전달하는 방식으로 사용된다 -- 💠")
closureParamFunction(closure: {
    print("벼리가 정의되면서 전달돼용")    //✨보통 이런식으로 정의를 하면서 전달된다!✨
})
/*=============================================================
 Callback함수 : 함수 실행 시 파라미터로 전달하는 함수
               ex.{ print("벼리가 정의되면서 전달돼용") }
 =============================================================*/




/*==============================================================
 클로저를 사용하는 이유 : 사후적 처리가 가능하다.
 사후적 처리란?
          :클로저함수에서 값을 받아서, -> 클로저를 파라미터로 받는 함수정의하는 곳에서 계산 후 ->계산결과를 클로저함수로 전달하는 방식
          :활용도가 늘어난다.
 ==============================================================*/
//예제(1)-----------------------------------------------------------
//클로저를 파라미터로 받는 함수정의
func closure01( a: Int, b: Int, closure001: (Int) -> Void){
    let c = a + b
//    closure001(c)
}

//클로저함수
closure01(a: 1, b: 1, closure001: { abc in
    print("벼리야옹 \(abc)")
})

print("예제2=========================")
//예제(2)-----------------------------------------------------------
//클로저를 파라미터로 받는 함수정의
func closure02(a: Int, b:Int, closure002: (Int) -> Void){
    let c = a + b
    closure002(c)
}

closure02(a: 3, b: 4, closure002: { n in       //3+4 를 내부적으로 하고, n 에 7을 전달 ...>7을 출력
     print(" 야옹? : \(n)")
})



//함수의 정의--------------->>>>>>>이부분을 잘 이해하자!!!!!!!
func perform(cl: () -> ()){
    print("시작")
    cl()
    print("끗")
}

perform(cl:{
    print("중간")
})
//함수의 정의--------------->>>>>>>


/*======================================================================
 ✨✨✨✨✨✨✨✨클로저의 문법 최적화✨✨✨✨✨✨✨✨
 ======================================================================*/
// 💎트레일링(trailling:꼬리) 후행클로저 :  함수의 마지막(꼬리)에 클로저가 실행되는 경우 함수의 소괄호 생략 가능.


func traillFunc(cl:()->Void){
    print("벼리가 한번 야옹")
    cl()
}

//1단계 원래형태
traillFunc(cl:{
    print("벼리 꼬리가 야옹1")   //벼리가 한번 야옹   벼리 꼬리가 야옹
})

//2단계 소괄호를 가져와서 앞에서 닫는 형태 (개발자들이 }뒤에 닫는거 계속 까먹으니까..)
traillFunc(cl: ){
    print("벼리 꼬리가 야옹2")   //벼리가 한번 야옹   벼리 꼬리가 야옹2
}

traillFunc( ){        //아규먼트 생략 가능
    print("벼리 꼬리가 야옹22")   //벼리가 한번 야옹   벼리 꼬리가 야옹22
}

//3단계 소괄호를 생략한 형태 - 함수를 사용하면서 클로저를 인풋으로 던지고 있구나!
traillFunc{
    print("벼리 꼬리가 야옹3")    //벼리가 한번 야옹   벼리 꼬리가 야옹3
}




/**
 $0 = 첫번째 파라미터
 $1 = 두번째 파라미터
 $2 = 세번째 파라미터*/
//💠💠💠💠💠💠💠💠💠💠💠클로저 문법을 최적화 하는 과정💠💠💠💠💠💠💠💠💠💠💠💠💠💠
//함수 정의
func pClosure(p : (String) -> Int){
    p("byuri")
}

//문법 최적화 시작
//1.클로저 함수
pClosure(p: { (br : String) in
    return br.count
})
//2.타입추론 - 타입생략
pClosure(p: { br in    //함수의 정의에 String 으로 타입 추론가능. -> String 생략
    return br.count
})
//3. 리턴 생략
pClosure(p: { br in
    br.count            //한줄인 경우 리턴 안적어도 됨.
})
//4.아규먼트 이름 생략
pClosure (p: {
    $0.count
})
//5. 아규먼트 이름이 생략되면 로직상 사용할 수 없기 때문에 $0,$1, $2..등으로 아규먼트 사용 가능.
pClosure(){
    $0.count
}
//6. 소괄호 생략 가능  -- 최종형태
pClosure{$0.count}
//💠💠💠💠💠💠💠💠💠💠💠💠💠💠💠💠💠💠💠💠💠💠💠💠💠💠💠💠💠💠💠💠💠💠💠💠💠



//escaping 키워드==================================================

//클로저를 단순 실행 ( non escaping ) --------------------------------
//원칙적으로는 함수를 종료하면 클로저도 종료됨
func performEscaping1(closure : () -> ()){
    print("print start")
    closure()
}

performEscaping1{
    print("printing....")
    print("print end")
}


/*============================================================
왜 escaping 키워드가 필요할까?
 - 어떤 함수의 내부에 있는 클로저를 외부 변수에 저장한다. escaping 함수를 통해서 [받은 함수]가 외부로 탈출할거야! 라고 알려주고 있는 것임.
 - 비동기 코드 (GCD) 의 사용 -> 예를들어 1초 뒤 클로저 함수를 실행하고 싶을 경우, heap영역에 저장해서 사용해야 한다.
 - 함수가 종료돼도 클로저 함수를 유지시킨다.
============================================================*/

//input, output 타입이 void인 함수를 선언해서 변수에 넣음
var aSaveFunction: () -> () = { print("출력")}
aSaveFunction()       //출력이 프린트됨

func performEscaping2( cls : @escaping () -> ()) {   //1. 외부에 있는 함수를 받아서, cls 에 넣은다음
    aSaveFunction = cls             //2. cls 를 aSaveFunction 변수에 넣음.
    //cls()  <- non escaping 방식은 이렇게 바로 cls를 호출한다
}


performEscaping2{ print("@escaping 키워드를 사용해서 출력") }  //이대로는 출력되지 않음 . 이 함수를 aSaveFunction에 출력하는 것 뿐이기때문에 ..

aSaveFunction()



//=============================================================================================




